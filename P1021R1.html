<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style>

.comment { color: #999999; font-style: italic; }
.pre { color: #000099; }
.string { color: #009900; }
.char { color: #009900; }
.float { color: #996600; }
.int { color: #999900; }
.bool { color: #000000; font-weight: bold; }
.type { color: #FF6633; }
.flow { color: #FF0000; }
.keyword { color: #990000; }
.operator { color: #663300; font-weight: bold; }
.operator { color: #663300; font-weight: bold; }
pre.code {
    border: 2px solid #666;
    background-color: #F4F4F4;
    padding-left: 10px;
    padding-top: 0px;
}
code {
    border: 2px solid #d0d0d0;
    background-color: LightYellow;
    padding: 2px;
    padding-left: 10px;
    display:table;
    white-space:pre;
    margin:2px;
    margin-bottom:10px;
}
dt {
    font-weight: bold;
}
.ins {
    background-color:#A0FFA0;
}
.del {
    background-color:#FFA0A0;
    text-decoration:line-through
}    
h3 { 
	margin-bottom: 0;
}
h4 { 
	margin-bottom: 0;
}
</style>

<title>Filling holes in Class Template Argument Deduction</title>
</head>

<body>
<p>P1021R1<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
2018-05-07<br>
Audience: Evolution Working Group
</p>
<h1>Filling holes in Class Template Argument Deduction</h1>
This paper proposes filling several gaps in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">Class Template Argument Deduction</a>.
<h2>Rationale</h2>
As Timur Doumler has noted when giving public presentations on using CTAD, he has to end the presentations with a list of where CTAD cannot be used, which always
	deflates the positive feelings from the rest of the talk because it is accurately regarded as artificially inconsistent. In particular, listeners are invariably surprised that it does not work with aggregate templates, type aliases, or inherited constructors or obey the normal rules for calling function templates.
    We will show in this paper
that these limitations can be safely removed. Note that most of these items were intentionally deferred to
    C++17 with the intent of adding them in C++20. In addition, as is explored in more depth in P????, if terse notation is adopted in C++, it will greatly benefit from having safe easy coding that does not require names
    for types. <p>The following
    preview (don't worry, all will be explained below) gives a taste
    for how much filling some small holes can smooth the road for some basic programming tasks (constraint notation from
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html">P1141R0</a>).
<!-- 
C++17 + P1141R0: 
Proposed: 
void f(Curve auto c) {
  Point<decltype(c.x_min())> top_left{c.x_min(), c.y_max()};
  pmr::vector<typename decltype(c.ctrl_pts)::value_type> v(c.ctrl_pts.begin(), c.ctr_pts.end(), mem_res);
  /* ... */
}

void f(Curve auto c) {
  Point upper_left_bound{c.x_min(), c.y_max()};
  pmr::vector v(c.ctrl_pts.begin(), c.ctr_pts.end(), mem_res);
  /* ... */
} -->
<table border="1"><tr><th>C++17 + P1141R0</th><th>Proposed</th></tr>
<tr><td><pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>template</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>class</span> T<span style='color:#800080; '>></span> Point <span style='color:#800080; '>{</span> T x<span style='color:#800080; '>;</span> T y<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>void</span> f<span style='color:#808030; '>(</span>Curve <span style='color:#800000; font-weight:bold; '>auto</span> c<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
  Point<span style='color:#808030; '>&lt;</span>decltype<span style='color:#808030; '>(</span>c<span style='color:#808030; '>.</span>x_min<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>></span> top_left<span style='color:#800080; '>{</span>c<span style='color:#808030; '>.</span>x_min<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> c<span style='color:#808030; '>.</span>y_max<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
  pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span><span style='color:#808030; '>&lt;</span><span style='color:#800000; font-weight:bold; '>typename</span> decltype<span style='color:#808030; '>(</span>c<span style='color:#808030; '>.</span>ctrl_pts<span style='color:#808030; '>)</span><span style='color:#800080; '>::</span>value_type<span style='color:#808030; '>></span> cp<span style='color:#808030; '>(</span>c<span style='color:#808030; '>.</span>ctrl_pts<span style='color:#808030; '>.</span>begin<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> c<span style='color:#808030; '>.</span>ctr_pts<span style='color:#808030; '>.</span>end<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* ... */</span>
<span style='color:#800080; '>}</span></pre></td>
<td><pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>template</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>class</span> T<span style='color:#800080; '>></span> Point <span style='color:#800080; '>{</span> T x<span style='color:#800080; '>;</span> T y<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>void</span> f<span style='color:#808030; '>(</span>Curve <span style='color:#800000; font-weight:bold; '>auto</span> c<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
  Point top_left<span style='color:#800080; '>{</span>c<span style='color:#808030; '>.</span>x_min<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> c<span style='color:#808030; '>.</span>y_max<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
  pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span> cp<span style='color:#808030; '>(</span>c<span style='color:#808030; '>.</span>ctrl_pts<span style='color:#808030; '>.</span>begin<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> c<span style='color:#808030; '>.</span>ctr_pts<span style='color:#808030; '>.</span>end<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#696969; '>/* ... */</span>
<span style='color:#800080; '>}</span>
</pre></td></tr></table>
 Despite being more precise, we do not believe that the extra boilerplate in the &ldquo;Before&rdquo; contributes to making the
    code clearer!
    
<h2>Class Template Argument Deduction for aggregates</h2>
We propose that Class Template Argument Deduction works for aggregate initialization as shown in the
    following example, where <tt>v</tt> is a vector of points and <tt>f()</tt> returns a vector of points:
<table border="1"><tr><th>C++17</th><th>C++17 attempted workaround</th><th>Proposed</th></tr>
<td><!--
// Point is aggregate, as intended
template<class T> 
struct Point { T x; T y};

// Aggregate: Cannot deduce
Point<double> p{3.0, 4.0};
Point<double> p2 {.x = 3.0, .y = 4.0};
Point<decltype(v[0].x)> p3 = v[0];
Point</*????*/> p4 = f()[0];
-->
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// Point is aggregate, as intended</span>
<span style='color:#800000; font-weight:bold; '>template</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>class</span> T<span style='color:#800080; '>></span> 
<span style='color:#800000; font-weight:bold; '>struct</span> Point <span style='color:#800080; '>{</span> T x<span style='color:#800080; '>;</span> T y<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#696969; '>// Aggregate: Cannot deduce</span>
Point<span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>double</span><span style='color:#800080; '>></span> p<span style='color:#800080; '>{</span><span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
Point<span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>double</span><span style='color:#800080; '>></span> p2 <span style='color:#800080; '>{</span><span style='color:#808030; '>.</span>x <span style='color:#808030; '>=</span> <span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>.</span>y <span style='color:#808030; '>=</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
Point<span style='color:#808030; '>&lt;</span>decltype<span style='color:#808030; '>(</span>v<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>x<span style='color:#808030; '>)</span><span style='color:#808030; '>></span> p3 <span style='color:#808030; '>=</span> v<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
Point<span style='color:#808030; '>&lt;</span><span style='color:#ffffff; background:#808000; '>????</span><span style='color:#808030; '>></span> p4 <span style='color:#808030; '>=</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
</pre>
</td>    
<td><!--// Workaround attempt: Try to emulate aggregate behavior through extra work
template<class T> 
struct Point { Point(T const &x, T T const &y): x{x}, y{y} {} T x; T y};

// Can deduce, but no longer an aggregate, unintentionally changing is_aggregate and more
Point p{3.0, 4.0};
Point p2 {.x = 3.0, .y = 4.0}; // Ill-formed - not aggregate
Point p3 = v[0];
Point p4 = f()[0];--><pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// Workaround attempt: Try to emulate aggregate behavior through extra work</span>
<span style='color:#800000; font-weight:bold; '>template</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>class</span> T<span style='color:#800080; '>></span> 
<span style='color:#800000; font-weight:bold; '>struct</span> Point <span style='color:#800080; '>{</span> Point<span style='color:#808030; '>(</span>T <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#808030; '>&amp;</span>x<span style='color:#808030; '>,</span> T T <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#808030; '>&amp;</span>y<span style='color:#808030; '>)</span><span style='color:#800080; '>:</span> x<span style='color:#800080; '>{</span>x<span style='color:#800080; '>}</span><span style='color:#808030; '>,</span> y<span style='color:#800080; '>{</span>y<span style='color:#800080; '>}</span> <span style='color:#800080; '>{</span><span style='color:#800080; '>}</span> T x<span style='color:#800080; '>;</span> T y<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#696969; '>// Can deduce, but inadvertently changed is_aggregate and more</span>
Point p<span style='color:#800080; '>{</span><span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
<s>Point p2 <span style='color:#800080; '>{</span><span style='color:#808030; '>.</span>x <span style='color:#808030; '>=</span> <span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>.</span>y <span style='color:#808030; '>=</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span></s> <span style='color:#696969; '>// Ill-formed - not aggregate</span>
Point p3 <span style='color:#808030; '>=</span> v<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
Point p4 <span style='color:#808030; '>=</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
</pre>
</td>
    <td><!--// Point is aggregate, as intended
template<class T> 
struct Point { T x; T y};

// Proposed: Aggregates deduce
Point p{3.0, 4.0};
Point p2 {.x = 3.0, .y = 4.0};
Point p3 = v[0];
Point p4 = f()[0];
--><pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// Point is aggregate, as intended</span>
<span style='color:#800000; font-weight:bold; '>template</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>class</span> T<span style='color:#800080; '>></span> 
<span style='color:#800000; font-weight:bold; '>struct</span> Point <span style='color:#800080; '>{</span> T x<span style='color:#800080; '>;</span> T y<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>

<span style='color:#696969; '>// Proposed: Aggregates deduce</span>
Point p<span style='color:#800080; '>{</span><span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
Point p2 <span style='color:#800080; '>{</span><span style='color:#808030; '>.</span>x <span style='color:#808030; '>=</span> <span style='color:#008000; '>3.0</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>.</span>y <span style='color:#808030; '>=</span> <span style='color:#008000; '>4.0</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
Point p3 <span style='color:#808030; '>=</span> v<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
Point p4 <span style='color:#808030; '>=</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
</pre></td>
    </table>

We propose simply that deduction takes place from the arguments. Since it was voted in Rapperswil that aggregate
    initialization proceed as if there was a synthesized constructor (does this apply to designated initializers and list-initialization?), we simply propose that the synthesized constructors have associated implicit deduction guides the same as other constructors do.

<h2>Class Template Argument Deduction for alias templates</h2>
While Class Template Argument Deduction makes type inferencing easier when constructing classes,
it doesn't work for type aliases, penalizing the use of type aliases and creating unnecessary inconsistency. We propose allowing Class Template Argument Deduction for type aliases. The following example illustrates
how it makes <tt>pmr::vector</tt> as easy to deduce as <tt>vector</tt> (<tt>c</tt>:
<table border="1"><tr><th><tt>vector</tt></th><th><tt>pmr::vector</tt> (C++17)</th><th>pmr::vector (proposed)</th></tr>
<tr>
    <td>
<!-- 
vector v = {1, 2, 3};
vector v2(cont.begin(), cont.end());
-->
<pre style='color:#000000;background:#ffffff;'><span style='color:#603000; '>vector</span> v <span style='color:#808030; '>=</span> <span style='color:#800080; '>{</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>3</span><span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
<span style='color:#603000; '>vector</span> v2<span style='color:#808030; '>(</span>cont<span style='color:#808030; '>.</span>begin<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> cont<span style='color:#808030; '>.</span>end<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>
    </td>
    <td>
<!-- 
pmr::vector<int> v({1, 2, 3}, mem_res);
pmr::vector<decltype(cont)::value_type> v2(cont.begin(), cont.end(), mem_res);
-->
<pre style='color:#000000;background:#ffffff;'>pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span><span style='color:#800080; '>&lt;</span><span style='color:#800000; font-weight:bold; '>int</span><span style='color:#800080; '>></span> v<span style='color:#808030; '>({</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>3</span><span style='color:#808030; '>},</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span><span style='color:#800080; '>&lt;</span>decltype<span style='color:#808030; '>(</span>cont<span style='color:#808030; '>)</span><span style='color:#800080; '>::</span>value_type<span style='color:#800080; '>></span> v2<span style='color:#808030; '>(</span>cont<span style='color:#808030; '>.</span>begin<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> cont<span style='color:#808030; '>.</span>end<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>
    </td>
<td>
 <!-- 
pmr::vector v({1, 2, 3}, mem_res);
pmr::vector v2(cont.begin(), cont.end(), mem_res);
-->
<pre style='color:#000000;background:#ffffff;'>pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span> v<span style='color:#808030; '>({</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>3</span><span style='color:#808030; '>}</span><span style='color:#808030; '>,</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
pmr<span style='color:#800080; '>::</span><span style='color:#603000; '>vector</span> v2<span style='color:#808030; '>(</span>cont<span style='color:#808030; '>.</span>begin<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> cont<span style='color:#808030; '>.</span>end<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> mem_res<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>
</td>
</tr></table>
In the spirit of alias templates being simply an alias for the type, we do not propose
allowing the programmer to write explicit deduction guides specifically for an alias
template.
	
<h2>Deducing from inherited constructors</h2>
Users may find it surprising that the following code is ill-formed.
<code>template &lt;typename T&gt; struct A { A(T); };
template &lt;typename T&gt; struct B : public A&lt;T&gt; { using A&lt;T&gt;::A; };
A a{3}; <span class="comment">// Ill-formed. Inherited constructors do not implictly define deduction guides</span></code>
This can make creating thin wrappers for classes (e.g., to just override a single method) cumbersome and error-prone, especially since the author of the derived class may need to manually replicate not only all the user-defined deduction guides of the base class but also all of the base class' implicitly-defined deduction guides as well. As a result, we propose that inheriting constructors from a base class also inherits their implicit and explicit deduction guides as well.<p>
    Of course, this only applies in cases where the derived classes template arguments are determined from the base class' template arguments. For example,</p> <code>template&lt;typename T&gt; struct B { B(T t); <span class="comment">/* ... */</span>};
template&lt;typename T, typename U&gt; struct D : B&lt;U&gt; {
  using B&lt;U&gt;::B;
  T t{};
};

B b{7}; <span class="comment">// B&lt;int&gt;</span>
D d{7}; <span class="comment">// Ill-formed</span>
D&lt;double&gt; d2{7}; <span class="comment">// D&lt;double, int&gt; by CTAD proposal for partially-specialized argument lists above</span></code>
We suspect the feature will be useful and that counterexamples such as <tt>struct D</tt> will be the exception since inherited constructors also tend to require (admittedly with some differences) that the construction of the derived class be largely determined by the construction of the base class. Indeed, the counterexample above was constructed through the at least somewhat esoteric technique of combining inherited constructors with non-static data member initializers for members of dependent types.
<p>Note that inheriting the constructors of a base class must include inheriting all the deduction guides, not just the implicit ones. As a number of standard library
writers use explicit guides to behave &ldquo;as-if&rdquo; their classes were defined as in the standard, such internal implementation details
details would become visible if only the internal guides were inherited.</p>

<h2>Class Template Argument Deduction and partially-specialized template argument lists</h2>
<b>Motivating examples: </b>
    Comparators are often cited as a good use for lambdas and are commonly passed to std::sort.
    However, in C++17 or earlier, as Nico Josuttis points out, lambda comparators fall on their face when creating associative containers.
	Consider this example (motivated by P0553R2 and <a href="https://stackoverflow.com/questions/47859991/stdset-operations-with-custom-comparator">this example</a> from
	Stack Overflow):
    <code>set&lt;int, <span class="comment">???</span>&gt; s([](int i, int j) { return std::popcount(i) &lt; std::popcount(j); }); <span class="comment">// Uh oh, no name for lambda type</span>
set s([](int i, int j) { return std::popcount(i) &lt; std::popcount(j); }); <span class="comment">// C++17 Class Template Argument Deduction doesn't work either</span></code>
What we want of course is for Class Template Argument Deduction to work with a partially-specialized argument list just
	like Function Template Argument Deduction does:
<code>set&lt;int&gt; s([](int i, int j) { return std::popcount(i) &lt; std::popcount(j); }); <span class="comment">// Proposed</span></code>
There are many other examples of partially specialized argument lists making coding simpler and less error-prone:
<code>map&lt;string, int&gt; caseInsensitiveWordCounts(boost::algorithm::ilexicographic_compare{}); <span class="comment">// Also helps for non-lambdas </span>
priority_queue&lt;Task&gt; tasks([](Task a, Task b) { return a.priority &lt; b.priority; }); <span class="comment">// and more than just associative containers </span></code>

<h3>Technical considerations</h3>
<p>The usefulness of partially-specialized argument lists in Class Template Argument Deduction was recognized during the C++17 cycle, but was deferred out of concern that interactions with default arguments could create a breaking change. Consider the following example
<code>template &lt;typename T, typename U = T&gt; struct A { A(T t, U u = U{}) {} };
template &lt;typename T, typename U = T> A&lt;T, U&gt; makeA(T t, U u = U{}) { return A(t,  u); }

auto a1 = A&lt;int&gt;(2, 3.5); <span class="comment">// C++17: A&lt;int, int&gt;</span>
auto a2 = makeA&lt;int&gt;(2, 3.5); <span class="comment">// A&lt;int, double&gt;</span>
</code>	

Here are some examples with standard library classes, consider the following (assuming the deduction guides like those in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0433r3.html">P0433R3</a>)
<code>map&lt;string, int&gt; caseInsensitiveWordCounts(boost::algorithm::ilexicographic_compare{}); <span class="comment">// C++17: Deduces map&lt;string, int, less&lt;string&gt;&gt;</span>
auto v = vector&lt;int&gt;(MyAlloc&lt;int&gt;{}); <span class="comment">// C++17: Deduces vector&lt;int, allocator&lt;int&gt;&gt;</span></code>
Of course, the first thing that springs to mind when looking at those examples is that C++17 (and earlier) deduce the wrong things. If we could have had Class Template Argument Deduction from the beginning, we certainly would have it behave like Function Template Argument Deduction and correctly
deduce <tt>map&lt;string, int, <span class="comment">lambda comparator</span>&gt;</tt> and <tt>vector&lt;int, MyAlloc&gt;</tt>.
	<p>Fortunately, we can get the benefit of the usual Function Template Argument Deduction without breaking existing code by the following rule:
If a class has no explicit deduction guides, C++17 behavior applies (acts like legacy C++ for classes that are not interested in CTAD). If it does have explicit guides, then do normal Function Template Argument Deduction. In particular, the above examples are handled correctly, and since any desired behavior can be specified, other examples can be handled as well.
</p>
<p>One other technical issue discussed during C++17 was around variadic templates. In particular, what should <tt>tuple&lt;int&gt;(1, 2.3)</tt> deduce?
Again, the C++17 behavior of <tt>tuple&lt;int&gt;</tt> is incorrect, as such templates have the wrong number of arguments. Fortunately, the normal
Function Template Argument Deduction behavior is a good choice here because it behaves like <tt>make_tuple&lt;int&gt;(1, 2.3)</tt> and deduces <tt>tuple&lt;int, double&gt;</tt>, satisfying the original goal for Class Template Argument Deduction of acting like make functions.</p>

<h2>Wording</h2>
<h2>Appendix</h2>
Table of all changes, their complexity, and risk. The idea is that very simple ones may be accepted.
</html>