<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style>

.comment { color: #999999; font-style: italic; }
.pre { color: #000099; }
.string { color: #009900; }
.char { color: #009900; }
.float { color: #996600; }
.int { color: #999900; }
.bool { color: #000000; font-weight: bold; }
.type { color: #FF6633; }
.flow { color: #FF0000; }
.keyword { color: #990000; }
.operator { color: #663300; font-weight: bold; }
.operator { color: #663300; font-weight: bold; }
pre.code {
    border: 2px solid #666;
    background-color: #F4F4F4;
    padding-left: 10px;
    padding-top: 0px;
}
code {
    border: 2px solid #d0d0d0;
    background-color: LightYellow;
    padding: 2px;
    padding-left: 10px;
    display:table;
    white-space:pre;
    margin:2px;
    margin-bottom:10px;
}
dt {
    font-weight: bold;
}
.ins {
    background-color:#A0FFA0;
}
.del {
    background-color:#FFA0A0;
    text-decoration:line-through
}    
h3 { 
	margin-bottom: 0;
}
h4 { 
	margin-bottom: 0;
}
</style>

<title>Extensions to Class Template Argument Deduction</title>
</head>

<body>
<p>P1021R2<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
2018-05-07<br>
Audience: Evolution Working Group
</p>
<h1>Extensions to Class Template Argument Deduction</h1>
This paper proposes several recommended extensions to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">Class Template Argument Deduction</a>
<h2>Rationale</h2>
We have several main motivations for extending Class Template Argument Deduction in C++20
<h3>Fix omissions in the original specification</h3>
As Timur Doumler notes when giving public presentations on using CTAD, he has to end the presentations with a list of where CTAD cannot be used, which is always negatively received because it is accurately regarded as inconsistent. In particular, listeners are invariably surprised that deduction guides are not implicitly generated for aggregate templates, type aliases, or inherited constructors. We will show in this paper
that these limitations can be safely removed.  

<h3>Making Class Template Argument Deduction like Function Template Argument Deduction</h3>
<p>Likewise, even though the original motivation for CTAD was to replace make functions as described in the section on
Template Argument Deduction for Constructors in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3405.html#deduction">n3405</a>, it has
unnecessary restrictions that can keep them from being used in place of make functions. In particular,
they cannot be used with partially-specialized template argument lists:
<code>auto t = make_tuple&lt;int&gt;('a', []() { <span class="comment">/* ... */</span>}); <span class="comment">// OK</span>
auto t = tuple&lt;int&gt;('a', []() { <span class="comment">/* ... */</span>}); <span class="comment">// Ill-formed!</span>

<span class="comment">// More useful example due to Nico Josuttis</span>
std::set&lt;Building&gt; buildings([](Building a, Building b) { return a.height() &lt; b.height(); }); <span class="comment">// Ill-formed :(</span></code>

<p>We also discuss several other useful ways to make Class Template Argument Deduction like Function Template Argument Deduction</p>
<h3>Help make terse notation a success</h3>
<p>If C++20 includes terse notation, having safe easy coding without requiring names for types becomes especially important. Indeed, we believe that the better CTAD works, the more positive the experience with terse notation will be. Consider the following example along the lines of 
	<a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0669r0.pdf">P0669</a>, (notation from
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html">P1141R0</a>).
    To see the relevance of CTAD, let us first write the example without CTAD:</p>
    <code>auto f(Shape auto &amp;s, Shape auto &amp; t) -> pair&lt;decltype(s), decltype(t.x)&gt;
{
  Point&lt;decltype(t.x)&gt; p{s.x, s.y};
  screen->line&lt;decltype(t.x)&gt;(p, {t.x, t.y});
  return {s, t.x };
};
</code>
    With CTAD, including the additions in this paper, the above code becomes simply
<code>pair f(Shape auto &amp;s, Shape auto &amp;t)
{
  point p{s.x, s.y};
  screen->line(p, {t.x, t.y});
  return {s, t.x };
};
</code>

More deeply, one can think of CTAD as a kind of dual companion to terse notation. Terse notation
describes constrained use of objects, while CTAD can be thought of as describing constrained creation of objects.

<h2>Fixing omissions in the original specification</h2>
<h3>Class Template Argument Deduction for aggregates</h3>
It seems awkward to us that the following does not work
<code>template&lt;typename T, typename U&gt; struct TU { T t; U u; };
TU&lt;int, double&gt; tu{1, 2.3}; <span class="comment">// OK</span>
TU tu2{1, 2.3}; <span class="comment">// Ill-formed</span></code>
especially when the following example does
<code>template&lt;typename T, typename U&gt; struct TU_ { TU_{T t, U u} : t{t}, u{u} {}; T t; U u; };
TU_&lt;int, double&gt; tu{1, 2.3}; <span class="comment">// OK</span>
TU_ tu2{1, 2.3}; <span class="comment">// OK. TU_&lt;int, double&gt;</span></code>
We propose that deduction takes place from the arguments. Rather than a deduction guide <em>per se</em>, this will need to use the same magic that aggregate initializers use to support the particular notations for aggregate initialization like <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf">designated initializers</a>.
<code>template&lt;typename T, typename U&gt; struct TUT { T t1; U u; T t2 = T{} };
TUT tut1 = { 1, 2.3, 2 }; <span class="comment">// TUT&lt;int, double&gt;{1, 2.3, 2}</span>
TUT tut2 = {.t1 = 3, u = 2.3 }; <span class="comment">// TUT&lt;int, double&gt;{3, 2.3, 0}</span></code>

<h3>Class Template Argument Deduction for alias templates</h3>
C++17 allows deduction for <tt>vector</tt> in cases such as
<code>vector v = {1, 2, 3}; <span class="comment">// vector &lt;int&gt;</span></code>
However, equally desirable code for <tt>pmr::vector</tt> fails because <tt>pmr::vector</tt> is an alias template and not a class template
<code>pmr::vector v = {1, 2, 3}; <span class="comment">// Ill formed. pmr::vector is not a class template</span></code>

<p>Furthermore, there is no way to perform CTAD for <tt>pmr::vector</tt> within C++17 language rules because alias templates cannot use CTAD. We believe that examples such as this motivate supporting CTAD for alias templates. We do note as a bikeshed that Class Template Argument Deduction is a misnomer for alias templates.</p>
	
<h3>Deducing from inherited constructors</h3>
Users may find it surprising that the following code is ill-formed.
<code>template &lt;typename T&gt; struct A { A(T); };
template &lt;typename T&gt; struct B : public A&lt;T&gt; { using A&lt;T&gt;::A; };
A a{3}; <span class="comment">// Ill-formed. Inherited constructors do not implictly define deduction guides</span></code>
This can make creating thin wrappers for classes (e.g., to just override a single method) cumbersome and error-prone, especially since the author of the derived class may need to manually replicate not only all the user-defined deduction guides of the base class but also all of the base class' implicitly-defined deduction guides as well. As a result, we propose that inheriting constructors from a base class also inherits their implicit and explicit deduction guides as well.<p>
    Of course, this only applies in cases where the derived classes template arguments are determined from the base class' template arguments. For example,</p> <code>template&lt;typename T&gt; struct B { B(T t); <span class="comment">/* ... */</span>};
template&lt;typename T, typename U&gt; struct D : B&lt;U&gt; {
  using B&lt;U&gt;::B;
  T t{};
};

B b{7}; <span class="comment">// B&lt;int&gt;</span>
D d{7}; <span class="comment">// Ill-formed</span>
D&lt;double&gt; d2{7}; <span class="comment">// D&lt;double, int&gt; by CTAD proposal for partially-specialized argument lists above</span></code>
We suspect the feature will be useful and that counterexamples such as <tt>struct D</tt> will be the exception since inherited constructors also tend to require (admittedly with some differences) that the construction of the derived class be largely determined by the construction of the base class. Indeed, the counterexample above was constructed through the at least somewhat esoteric technique of combining inherited constructors with non-static data member initializers for members of dependent types.

	<h2>Making Class Template Argument Deduction like Function Template Argument Deduction</h2>
<h3>Class Template Argument Deduction and partially-specialized template argument lists</h3>
<b>Motivating examples: </b>
    Comparators are often cited as a good use for lambdas and are commonly passed to std::sort.
    However, in C++17 or earlier, it is hard to 
    <code>set&lt;Building&gt; s([](int x, int y) { return x.height &lt; y.height; });</code>
<p>In C++17, we deferred allowing CTAD to be applied in declarations with partially-specialized template argument lists out of concern that interactions with default arguments could create a breaking change. Consider the following example
<code>template &lt;typename T, typename U = T&gt; struct A { A(T t, U u = U{}) {} };
template &lt;typename T, typename U = T> A&lt;T, U&gt; makeA(T t, U u = U{}) { return A(t,  u); }

auto a1 = A&lt;int&gt;(2, 3.5); <span class="comment">// C++17: A&lt;int, int&gt;</span>
auto a2 = makeA&lt;int&gt;(2, 3.5); <span class="comment">// A&lt;int, double&gt;</span>
</code>	
<p>To add support for partially-specialized template argument lists in declarations, we would have to decide what we want <tt>A&lt;int&gt;(2, 3.5)</tt> to deduce. The options are</p>
<ol><li><tt>A&lt;int, int&gt;</tt> as it currently does.</li>
	<li><tt>A&lt;int, double&gt;</tt> as a function template like <tt>makeA()</tt> does.</li>
	<li>Make it ambiguous when options 1 and option 2 would give a different answer.</li></ol>
<p>We can compare these approaches with some motivating examples (assuming the deduction guides like those in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0433r3.html">P0433R3</a>)</p>	
<code>map&lt;string, int&gt; caseInsensitiveWordCounts(boost::algorithm::ilexicographic_compare{});
auto v = vector&lt;int&gt;(MyAlloc&lt;int&gt;{});</code>After considering examples such as the above, we propose adopting approach 2 for the following reasons.
	<ul><li>In both of the motivating examples, approach 2 deduces correctly while 1 and 3 fail to compile.</li>
	<li>We think approach 2 makes the language more consistent by giving deduction guides the same deduction rules as function templates while options 1 and 3 (as well as current C++17 behavior) create differences in how deduction guides and make functions handle partial specializations.</li>
<li>In cases where both approach 1 and 2 compile, we think that any differences in legacy code have a high likelihood of being due to bugs. E.g., in the (admittedly artificial) <tt>struct A</tt> example, the user almost certainly expects <tt>a2</tt> to be <tt>A&lt;int, double&gt; </tt> else why would they be passing it 3.5?</li>
<li>If the legacy C++17 behavior is desired for some class, that can still be achieved with a deduction guide. However, the opposite is not the case if deduction guides cannot be used in partially-specialized template argument lists in declarations.</li></ul>

	<h3>Argument deduction for function templates</h3>
Using Class Template Argument Deduction for Function Template Arguments also greatly simplifies common programming tasks.
For example, we believe the following code would be natural and useful
<code>template &lt;typename T&gt; void f(optional&lt;T&gt;);
template &lt;typename CharT, typename Traits&gt; void g(basic_string_view&lt;CharT, Traits&gt;);
<span class="comment">/* ... */</span>
f(7);     // Would like to deduce f&lt;int&gt; with arg of optional&lt;int&gt;
</code>
To see just how useful this is, allowing CTAD to deduction arguments of function templates would have trivially
allowed all three &ldquo;output&rdquo; overloads of <tt>std::quoted</tt> to be trivially subsumed in just the <tt>quoted(basic_string_view&lt;charT, traits&gr;, charT, charT)</tt> constructor. Just think how much simpler it would to get functions like the &ldquo;output&rdquo; form of
	<tt>std::quoted</tt> correct and consistent if instead of manually writing all of the following overloads
<code>template&lt;class charT&gt;
T11 quoted(const charT* s, charT delim = charT(’"’), charT escape = charT(’\\’));
template&lt;class charT, class traits, class Allocator&gt;
T12 quoted(const basic_string&lt;charT, traits, Allocator&gt;&amp; s,
charT delim = charT(’"’), charT escape = charT(’\\’));
template&lt;class charT, class traits, class Allocator&gt;
T14 quoted(basic_string_view&lt;charT, traits, Allocator&gt;&amp; s,
charT delim = charT(’"’), charT escape = charT(’\\’));</code>
we only had to write the <tt>basic_string_view</tt> constructor
<code>T14 quoted(basic_string&lt;charT, traits, Allocator&gt;&amp; s,
charT delim = charT(’"’), charT escape = charT(’\\’));</code>
	The additional boilerplate is error-prone and exists only because the language cannot make the obvious constructor
	deduction, even though it can do so for any declarations that are not arguments.

	
<h3>Deduction guides for function templates</h3>
<p>One very prominent way in which Constructor Template Argument Deduction differs from Function Template Argument Deduction
is that Function Template Argument Deduction cannot be guided. Unsurprisingly, deduction guides are just as useful for
Function Template Argument Deduction as Class Template Argument Deduction as shown by the examples below</p>
<h4>Example: Unwrapping reference wrappers</h4>
<p><tt>std::reference_wrapper</tt> is commonly used to effect pass-by-reference 
to function templates with generic parameter types. Writing a function template
that can be used this way is naturally simplified with deduction guides.</p>
<code>template &lt;typename T&gt; void f(T t) { t.foo(); <span class="comment">/* ... */</span>}
template &lt;T&gt; f(reference_wrapper&lt;T&gt;) -&gt; f&lt;T &amp;&gt;;</code>
Now <tt>f</tt> will unwrap reference wrappers arguments.
<code>struct X { void foo(); <span class="comment">/* ... */</span>};
int main()
{
	X x;
	f(ref(x)); <span class="comment">// Passes by reference as desired. Ill-formed without deduction guide</span>
}
</code>
<p><b>Note:</b> In C++ 17, something similar may be accomplished by rewriting <tt>f</tt> as
<code>// Helper for converting reference wrappers to references
template &lt;typename T&gt; struct unwrap { using type = T };
template &lt;typename T&gt; struct unwrap&lt;std::reference_wrapper&lt;T&gt;&gt; { using type = T &amp; }
template &lt;typename T&gt; using unwrap_t = typename unwrap&lt;T&gt;::type;

template &lt;typename T&gt; void f(T t) 
{
	remove_reference_t&lt;unwrap_t&lt;T&gt;&gt; &amp;actualT{t};
	actualT.foo(); <span class="comment">/* ... */</span> 
}</code>
However, not only is this more cumbersome in our opinion, it requires that the user of <tt>f</tt> look inside the implementation of <tt>f</tt> to understand
that it conforms to the &ldquo;<tt>reference_wrapper</tt> mini-language&rdquo;, whereas the proposed version
advertises that in the interface.</p>
<h4>Example: Efficient parameter passing</h4>
<p>For function templates that accept a <tt>const</tt> argument, it is generally most efficient to pass
small argument types, such as <tt>int</tt>, by value and large or uncopyable types by <tt>const &amp;</tt>.
The Boost Call Traits library has a <tt>call_traits&lt;T&gt;::param_type</tt> traits that gives the
most efficient way to pass, but it is awkward to to use. 
<code>// C++17
template &lt;typename T&gt; void do_f(T t); <span class="comment">// Implements f</span>

template &lt;typename T&gt; inline void f(T &amp;&amp; t)
{
	do_f&lt;typename boost::call_traits&lt;decay_t&lt;T&gt;&gt;::type&gt;(t);
}</code>
With deduction guides, this again naturally simplifies to a form that no longer requires examining the body of <tt>f</tt>
<code>template &lt;typename T&gt; void f(T t); <span class="comment">// Implement here. No need to delegate</span>
template &lt;typename T&gt; f(T t) -> f&lt;typename boost::call_traits&lt;T&gt;::type&gt;;</code>

<h4>Example: Delayed forwarding</h4>
The following example, due to Richard Smith, applies function deduction guides to delayed forwarding in order to convert to the callee's types in the caller. E.g., to eliminate the need to use <tt>std::ref</tt> if the callee expects a reference (this has been known to <a href="https://stackoverflow.com/questions/18359864/passing-ents-to-stdasync-by-reference-fails">bite</a> users of <tt>async</tt> as well as of <tt>thread</tt>'s constructor template).
<code><span class="comment">// Assume p0945r0 and std::experimental::invocation_type</span>
template&lt;typename F, typename R, typename ...T&gt;
future&lt;R&gt; call_later(F fn, T ...t);

template&lt;typename F, typename T&gt; struct call_later_helper;
template&lt;typename F, typename R, typename ...T&lt; struct call_later_helper&lt;R(T...)&gt; {
  using call_later = ::call_later&lt;F, R, T...&gt;;
};

template&lt;typename F, typename ...T&gt;
call_later(F fn, T &amp;&amp;...t) -> call_later_helper&lt;F, invocation_type_t&lt;F, T&amp;&amp;...&gt;&gt;::call_later;
</code>

	
<h2>Help make terse notation a success</h2>	
As described in the rationale above, terse notation works better in the presence of Class Template Argument Deduction in general.
	However, the <b>Relaxed &ldquo;constraint <tt>auto</tt>&rdquo;</b> section of P1141R0 notes that the relationship is even closer
	than that, proposing that <tt>Constraint x = f();</tt> should behave like <tt>tuple t = f();</tt>. Indeed, the language is simplified
	by consistently aligning CTAD to terse notation. Indeed, just as P1141R0 proposes the principle that &ldquo;wherever <tt>auto</tt> goes,
	a <tt>Constraint auto</tt> can also (non-recursively) go&rdquo;, we think a <tt>ClassTemplateName auto</tt> can also go. Let us
	look at the different cases.
<h3>Allowing <tt>auto</tt> for declarations</h3>
Just like P1141R0 says that <tt>Constraint x = f();</tt> should behave like <tt>tuple t = f();</tt>, we should also allow
	 <tt>tuple auto t = f();</tt> to behave like <tt>Constraint auto x = f();</tt>. This way the programmer can use or omit <tt>auto</tt>
	consistently as a sigil for deduction consistently as they desire.
<h3>Return type deduction for functions</h3>
 to allow Class Template Argument Deduction as code like the following appears both useful and natural to us.
<code>tuple auto f() { return {3, 5}; } // tuple&lt;int, int&gt;</code>
As usual, all return statements should deduce the same type.
<code>optional f() { return 7; }                                      <span class="comment">// optional&lt;int&gt;</span>
auto g() -> optional { if(noValue()) return {} else return 7; } <span class="comment">// optional&lt;int&gt;</span>
optional h() { if(foo()) return "bar" else return 7; }          <span class="comment">// Ill-formed: Ambiguous</span>
</code>

<h3><tt>auto</tt> deduction for arguments</h3>
If I write a text processing function, I would like to simply be able to say
<code>void process_text(string_view auto x);</code>
just like I would with any template concept.
</body></html>