<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
     <style>
/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: white !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: white !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: white !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #e0e0e0 !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: black !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #afafaf !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #6ce26c !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #6ce26c !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: blue !important;
  background: white !important;
  border: 1px solid #6ce26c !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: blue !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .toolbar {
  color: white !important;
  background: #6ce26c !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: white !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: black !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #008200 !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: blue !important;
}
.syntaxhighlighter .keyword {
  color: #006699 !important;
}
.syntaxhighlighter .preprocessor {
  color: gray !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #006699 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .keyword {
  font-weight: bold !important;
}
.syntaxhighlighter div.toolbar span a.toolbar_item{
   display: none !important;
} 
body .syntaxhighlighter .line {
    white-space: pre !important;
}
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.clo,.opn,.pun{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.kwd,.tag,.typ{font-weight:700}.str{color:#060}.kwd{color:#006}.com{color:#600;font-style:italic}.typ{color:#404}.lit{color:#044}.clo,.opn,.pun{color:#440}.tag{color:#006}.atn{color:#404}.atv{color:#060}}pre.prettyprint{padding:2px;border:1px solid #888}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
    </style>

<title>Wording for Class Template Argument Deduction for Alias Templates and Inherited Constructors</title>
</head>

<body>
<p>D1814R0<br>
Mike Spertus, Symantec<br>

Audience: Core Working Group
</p>
<h1>Wording for Class Template Argument Deduction for Alias Templates and Inherited Constructors
</h1>
This paper provides wording for the Alias Template and Inheriting Constructors Class Template Argument Deduction support from 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1021r4.html">P1021R4</a>.

<h2>Document revision history</h2>

<b>R0</b>, 2019-07-15: Split from P1021R4<br>

<h2>Wording</h2>
<p>Modify (dcl.type.simple/2) as follows</p>
<blockquote>
A <em>placeholder-type-speciﬁer</em> is a placeholder for a type to be deduced (9.1.7.5). A <em>type-speciﬁer</em> of the form
    <tt>typename</tt><sub><em>opt</em></sub> <em>nested-name-specifier<sub>opt</sub> template-name</em> is a placeholder for a deduced class type (9.1.7.6).
    The <em>template-name</em> shall name a class template <ins>or an alias template whose <em>defining-type-id</em> is of the form 
    <tt>typename</tt><sub><em>opt</em></sub><em>nested-name-specifier::simple-type-id</em> 
    and the <em>nested-name-specifier</em> (if any) is non-dependent and whose template-name.</ins>
</blockquote>
    Modify the first paragraph of (dcl.type.class.deduct) as follows
    <blockquote>If a placeholder for a deduced class type appears as a <em>decl-speciﬁer</em> in the <em>decl-speciﬁer-seq</em> of an initializing
declaration (9.3) of a variable, the placeholder is replaced by the return type of the function selected by
overload resolution for class template deduction (11.3.1.8)</blockquote>
    <p>In over.match.class.deduct, append to paragraph 1 as follows:</p>
<blockquote>    <p><ins>In addition, if <tt>C</tt> inherits constructors (namespace.udecl 9.8) 
        from a base
        class denoted by a <em>simple-template-id</em> <tt>B</tt>, 
          the set contains the functions
      and function templates formed from an
        alias template from the procedure in (over.match.class.deduct) whose template parameters are those of <tt>C</tt>
    and whose <em>simple-template-id</em> is <tt>B</tt>.</ins></p></blockquote>

Add the following after the first paragraph of over.match.class.deduct 
<blockquote><ul><ul><li>The return type is the <em>simple-template-id</em> of the
<em>deduction-guide</em>.</li></ul></ul><ins>When resolving a placeholder for a deduced class type (dcl.type.simple 9.1.7.2) where the
	<em>template-name</em> names an alias template <tt>A</tt> 
	whose <em>defining-type-id</em> is a <em>simple-template-id</em>
    naming a specialization of an alias or class template
    <tt>B</tt> with template argument list <em>L</em> denoting
    a type that is a specialization of class template <tt>C</tt>, a
	set of function or function templates is formed as follows. For each function or function
	template <tt>f</tt> (recursively) formed for <tt>B</tt> by the process in 
    (over.match.class.deduct), 
    add a function or function
	template <tt>f'</tt> to the set. <tt>f'</tt> is formed 
    according to the following procedure:
	<ul><li>Deduce the template arguments of the return type of <tt>f</tt>
    from <tt>B&lt;L&gt;</tt>
	according to the process in (temp.deduct.type) with the exception that deduction does
	not fail if not all template arguments are deduced. Let <tt>g</tt>
    denote the result of substituting these deductions into <tt>f</tt>.
        If the substitution fails, no <tt>f'</tt> is produced.</li>
		<li>Form the function or function template <tt>f'</tt> as follows:
		<ul><li>The function type of <tt>f'</tt> is the function type of <tt>g</tt>.
		<li>If <tt>f</tt> is a function template, 
            the template parameter list of <tt>f'</tt>
            consists of all the template parameters of <tt>A</tt>
            (including their default template arguments)
            that appear in the above deductions or (recursively) in their
            default template arguments, followed by
            the template parameters of <tt>f</tt> that were
            not deduced (including their default template arguments).</li>
        
		<li>The associated constraints (temp.constr.decl 12.4.2) are the conjunction of the associated constraints of <tt>g</tt> and a constraint that is satisfied if and only if the arguments of <tt>A</tt> are deducible (see below) from the return type.</li></ul>
        <li>If <tt>f</tt> is a copy deduction candidate (over.match.class.deduct 11.3.1.8), then <tt>f'</tt>
                is considered to be so as well.</li>
            <li>
			If <tt>f</tt> was generated from a <em>deduction-guide</em> (over.match.class.deduct 11.3.1.8), then <tt>f'</tt>
                is considered to be so as well.</li>
        <li>The <em>explicit-specifier</em> of <tt>f'</tt> is the <em>explicit-specifier</em> of <tt>g</tt> (if any).</li></ul>
		
    The arguments of a template <tt>A</tt> are said to be deducible from a type <tt>T</tt> if, given a class template
<blockquote><pre>template &lt;typename&gt; class AA;</pre></blockquote>

    with a single partial specialization whose template parameter list is that of <tt>A</tt> and whose template argument list is a specialization of <tt>A</tt> with the template argument list of <tt>A</tt> (temp.dep.type), <tt>AA&lt;T&gt;</tt> matches the partial specialization.
    </ins><p>
	Initialization and overload resolution are performed as described in 
    (dcl.init 9.3) and (over.match.ctor 12.3.1.3), 
    (over.match.copy 12.3.1.4), or (over.match.list 12.3.1.7) (as
    appropriate for the type of initialization performed) for an object of a hypothetical class type, ...</p></blockquote> 
	Add the following example to the end of over.match.class.deduct
	<blockquote><blockquote><tt>B b{(int*)0, (char*)0};
// OK, deduces B&lt;char*&gt;</tt></blockquote>
— <em>end example</em> ]<br><br>
    <ins>[<em>Example:</em><pre>
	template &lt;class T, class U&gt; struct C {
	  C(T, U);   // #1
	};
	template&lt;class T, class U&gt;
	C(T, U) -&gt; C&lt;T, std::type_identity_t&lt;U&gt;&gt;; // #2
	
	template&lt;class V&gt;
	using A = C&lt;V *, V *&gt;;
        template&lt;class W&gt;
        using B = A&lt;W&gt; requires Integral&lt;W&gt;;
	
	int i{};
	double d{};
	A a1(&amp;i, &amp;i); // Deduces <em>A&lt;int&gt;</em>
	A a2(i, i);   // <em>Error: cannot deduce V * from i</em>
	A a3(&amp;i, &amp;d); // <em>Error: #1: Cannot deduce (V*, V*) from (int *, double *) </em>
                                #2: Cannot deduce C&lt;V&gt; from C&lt;int *, double *&gt;
        B b1(&amp;i, &amp;i); // Deduces B&lt;int&gt;
        B b2(&amp;d, &amp;d); // Error: cannot deduce B&lt;W&gt; from C&lt;double *, double *&gt;;
	</pre>
    Possible exposition only implementation of the above procedure:
	<pre>        //<em>The following concept ensures a specialization of A is deduced</em>
        template &lt;class&gt; class AA;
        template &lt;class V&gt; class AA&lt;A&lt;V&gt;&gt; { };
        template &lt;class T&gt; concept deduces_A = requires { sizeof(AA&lt;T&gt;); };
        
        // <em>f is formed (over.match.class.deduct 11.3.1.8) from the deduction-guide of C</em>
        template&lt;class T, class U&gt; auto f(T, U) -&gt; C&lt;T, std::type_identity_t&lt;U&gt;&gt;;

        // <em>Deducing arguments for C&lt;T, std::type_identity_t&lt;U&gt;&gt; from C&lt;V *, V*&gt; deduces T as V *</em>
	
	// <em>f' is obtained by transforming f as described by the above procedure</em>
	template&lt;class V, class U&gt; 
	auto f_prime(V *, U) -&gt; C&lt;V *, std::type_identity_t&lt;U&gt;&gt;
	  requires deduces_A&lt;C&lt;V *, std::type_identity_t&lt;U&gt;&gt;&gt;;
         
        // <em>Likewise, f2 is formed from the C(T, U) constructor of C,</em>
        // <em>generating the following function template</em>
  	auto f2_prime(V *, V*) -&gt; C&lt;V *, V *&gt;
	  requires deduces_A&lt;C&lt;V *, V *&gt;&gt;;
   
        // <em>The following concept ensures a specialization a B is deduced</em>
        template &lt;class&gt; class BB;
        template &lt;class V&gt; class BB&lt;B&lt;V&gt;&gt; { };
        template &lt;class T&gt; concept deduces_B = requires { sizeof(BB&lt;T&gt;); };
        
        // <em>f2 is formed from the C(T, U) constructor of C</em>
        
        // The function templates for B derived from the above f' and f2' for A is
 	template&lt;class W, class U&gt; 
	auto f_prime_for_B(W *, U) -&gt; C&lt;W *, std::type_identity_t&lt;U&gt;&gt;
	  requires deduces_A&lt;C&lt;W *, std::type_identity_t&lt;U&gt;&gt;&gt;
                &amp;&amp; deduces_B&lt;C&lt;W *, std::type_identity_t&lt;U&gt;&gt;&gt;;
	auto f2_prime_for_B(T, U) -&gt; C&lt;T, U&gt;
	  requires deduces_A&lt;C&lt;T, U&gt;&gt;&gt;
                &amp;&amp; deduces_B&lt;C&lt;T, U&gt;&gt;&gt;;
	</pre>

	<em>&mdash; end example</em>]
		</ins></blockquote>
Insert a bullet after over.match.best/2.9 as follows
	<blockquote><blockquote><tt>bool b = 1 &lt; S();</tt>
// <em>calls #2</em>
— end example
] or, if not that</blockquote>
	<ul><ins><li><tt>F1</tt> is generated from class template argument deduction (over.match.class.deduct 11.3.1.8) for
		a class <tt>D</tt>, <tt>F2</tt> is generated from inheriting constructors from
		a base class of <tt>D</tt>, and for all arguments the corresponding
        parameters of <tt>F1</tt> and <tt>F2</tt> have the same type, or if not that,</li></ins>
        <li><tt>F1</tt> is generated from a <em>deduction-guide</em> (12.3.1.8) and <tt>F2</tt> is not, or, if not that</li></ul></blockquote>

    <script type="text/javascript">
	SyntaxHighlighter.defaults['gutter'] = false;
     SyntaxHighlighter.all()
</script>
	</body></html>