<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<!--<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>-->
<script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <style>
.syntaxhighlighter div.toolbar span a.toolbar_item{
   display: none !important;
} 
body .syntaxhighlighter .line {
    white-space: pre !important;
}

    </style>
<title>Why Class Template Argument Deduction will make Terse Notation better</title>
</head>

<body>
<p>D1168R0<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
2018-??-??<br>
Audience: Evolution Working Group
</p>
<h1>Why Class Template Argument Deduction will make Terse Notation better</h1>
Terse concept notation along the lines of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html">P1141R0</a> has
the potential to powerfully make generic programming look more like &ldquo;regular
programming&rdquo;. This paper discusses how Class Template Argument
Deduction can help make the release of terse notation as successful as
possible by providing inferenced creation of constrained objects
just as concepts provide inferenced usage of constrained objects
as illustrated by the following example.
<table border="1"><tr><th>C++17 + P1141R0</th><th>Proposed</th></tr>
<tr><td>
<pre class="brush:cpp">auto f(Curve auto &amp;c)
  -&gt; pair&lt;decltype(c), pmr::vector&lt;typename decltype(c.ctrl_pts)::value_type&gt;&gt;
{
  Point&lt;decltype(c.x_min())&gt; top_left{c.x_min(), c.y_max()};
  screen->line&lt;decltype(p.x)&gt;(p, {c.x_min(), c.y_max()});
  pmr::vector&lt;typename decltype(c.ctrl_pts)::value_type&gt; cp(c.ctrl_pts.begin(), c.ctrl_pts.end(), mem_res);
  return {c, cp };
};</pre></td>
<td valign="top">
<pre class="brush:cpp">pair auto f(Curve auto &amp;c, basic_ostream auto logger)
{
  Point top_left{c.x_min(), c.y_max()};
  screen->line(top_left, {c.x_min(), c.y_max()});
  pmr::vector cp(c.ctrl_pts.begin(), c.ctrl_pts.end(), mem_res);
  return {c, cp};
};</pre></td>
</tr></table>
What is going on here? Terse notation has many benefits because it
allows us to prefer interface/behavior over implementation when
using objects, with all the well-known benefits associated thereto.
This is a very good thing, but, like everything, has a few tradeoffs.
In particular, it is more common to have named objects without
named types. The main use of course for concrete types is for object
creation, where an actual type, rather than just the requirements it
satisfies, needs to be specified somehow. Class Template Argument Deduction 
is a way to create new objects from existing objects where the new
type is inferred, rather than needing to be explicitly stated, which
is just what the doctor ordered for flexible and robust code in examples
such as the above.
<p>While C++17 Class Template Argument Deduction can often be
used in such situations (e.g., if the <tt>pmr::vector</tt> above
had been an ordinary <tt>vector</tt>), the example above
was crafted to illustrate the value of potential improvements
to Class Template Argument Deduction, such as return type
deduction below, and aggregate and type alias deduction from P1021R1.
<table border="1"><tr><th>C++17 + P1141R0</th><th>Proposed</th></tr>
<tr><td>
<pre class="brush:cpp">template&lt;class CharT, class Traits&gt;
auto f(Curve auto &amp;c, basic_ostream&lt;charT, Traits&gt; logger)
  -&gt; pair&lt;decltype(c), pmr::vector&lt;typename decltype(c.ctrl_pts)::value_type&gt;&gt;
{
  Point&lt;decltype(c.x_min())&gt; top_left{c.x_min(), c.y_max()};
  screen->line&lt;decltype(p.x)&gt;(p, {c.x_min(), c.y_max()});
  logger &lt;&lt; "Drew line\n";
  
  pmr::vector&lt;typename decltype(c.ctrl_pts)::value_type&gt; cp(c.ctrl_pts.begin(), c.ctrl_pts.end(), mem_res);
  logger &lt;&lt; "Got control points: ";
  copy(cp.begin(), cp.end(),
       ostream_iterator&lt;decltype(cp[0]),
	                    typename decltype(logger)::char_type,
	                    typename decltype(logger)::traits_type&gt;(logger, ", "));
  return {c, cp };
};</pre></td>
<td valign="top">
<pre class="brush:cpp">pair auto f(Curve auto &amp;c, basic_ostream auto logger)
{
  Point auto top_left{c.x_min(), c.y_max()};
  screen->line(top_left, {c.x_min(), c.y_max()});
  logger &lt;&lt; "Drew line\n";

  pmr::vector cp(c.ctrl_pts.begin(), c.ctrl_pts.end(), mem_res);
  logger &lt;&lt; "Got control points: ";
  copy(cp.begin(), cp.end(),
       ostream_iterator&lt;decltype(cp[0])&gt;(logger, ", "));
  return {c, cp};
};</pre></td>
</tr></table>
<h2>Wording</h2>
<h2>Futures</h2>
<h3><tt>auto</tt> for base classes</h3>
<h3>Deduction guides for concepts</h3>
	While it was pointed out above that during object creation an
actual type, rather than just its requirements, needs to be
provided, that need not be true.

<script type="text/javascript">
	SyntaxHighlighter.defaults['gutter'] = false;
     SyntaxHighlighter.all()
</script>
</body>
</html>