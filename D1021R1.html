<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
 <head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<!--<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>-->
<script src='http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js' type='text/javascript'></script>
    <style>
.syntaxhighlighter div.toolbar span a.toolbar_item{
   display: none !important;
} 
body .syntaxhighlighter .line {
    white-space: pre !important;
}

    </style>

<title>Filling holes in Class Template Argument Deduction</title>
</head>

<body>
<p>P1021R1<br>
Mike Spertus, Symantec<br>
<a href="mailto:mike_spertus@symantec.com">mike_spertus@symantec.com</a><br>
Timur Doumler<br>
<a href="mailto:papers@timur.audio">papers@timur.audio</a><br>
2018-??-??<br>
Audience: Evolution Working Group
</p>
<h1>Filling holes in Class Template Argument Deduction</h1>
This paper proposes filling several gaps in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html">Class Template Argument Deduction</a>.
<h2>Rationale</h2>
As Timur Doumler has noted when giving public presentations on using CTAD, he has to end the presentations with a list of where CTAD cannot be used, which always
	deflates the positive feelings from the rest of the talk because it is accurately regarded as artificially inconsistent. In particular, listeners are invariably surprised that it does not work with aggregate templates, type aliases, or inherited constructors or obey the normal rules for calling function templates.
    We will show in this paper
that these limitations can be safely removed. Note that most of these items were intentionally deferred to
    C++17 with the intent of adding them in C++20. In addition, as is explored in more depth in P????, if terse notation is adopted in C++, it will greatly benefit from having safe easy coding that does not require names
    for types. <p>The following rough example gives an idea of how much filling holes can smooth the road. 
    It also includes some notation from
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1141r0.html">P1141R0</a>
    to illustrate how much terse constrants benefit from improved inferencing in Class Template
    Argument Deduction, a theme examined in depth in <a href="https://htmlpreview.github.io/?https://github.com/mspertus/CTAD_POST_CPP17/blob/master/D1168R0.html">D1168R0</a>. 

<table border="1"><tr><th>C++17 + P1141R0</th><th>Proposed</th></tr>
<tr><td><pre class="brush:cpp">void f(Curve auto c) {
  Point&lt;decltype(c.x_min())&gt; top_left{c.x_min(), c.y_max()};
  pmr::vector&lt;typename decltype(c.ctrl_pts)::value_type&gt; v(c.ctrl_pts.begin(), c.ctr_pts.end(), mem_res);
  /* ... */
}</pre></td>
<td><pre class="brush:cpp">void f(Curve auto c) {
  Point upper_left_bound{c.x_min(), c.y_max()};
  pmr::vector v(c.ctrl_pts.begin(), c.ctr_pts.end(), mem_res);
  /* ... */
} </pre></td></tr></table>
 To see that this really falls under the category of filling holes, the above code would work in C++17
if we just gave <tt>Point</tt> a two argument constructor corresponding to aggregate initialization
and used <tt>vector</tt> instead of <tt>pmr::vector</tt>.
    
<h2>Class Template Argument Deduction for aggregates</h2>
We propose that Class Template Argument Deduction works for aggregate initialization as one
	shouldn't have to choose between having aggregates and deduction. This is well illustrated
	by the following example, where <tt>v</tt> is a vector of (some specialization of) <tt>Point</tt> 
	and <tt>f()</tt> returns a vector of (some specialization of) <tt>Point</tt>:
<table border="1"><tr><th>C++17</th><th>Proposed</th></tr>
<td><pre class="brush:cpp">template&lt;class T&gt;
struct Point { T x; T y};

// Aggregate: Cannot deduce
Point&lt;double&gt; p{3.0, 4.0};
Point&lt;double&gt; p2 {.x = 3.0, .y = 4.0};
Point&lt;decltype(v[0].x)&gt; p3 = v[0];
Point&lt;/*????*/&gt; p4 = f()[0];</pre>
</td>    
    <td><pre class="brush:cpp">template&lt;class T&gt;
struct Point { T x; T y};

// Proposed: Aggregates deduce
Point p{3.0, 4.0};
Point p2 {.x = 3.0, .y = 4.0};
Point p3 = v[0];
Point p4 = f()[0];
</pre></td>
    </table>

In other words, deduction should take place simply from the arguments. Since it was voted in Rapperswil that aggregate
    initialization proceed as if there was a synthesized constructor (does this apply to designated initializers and list-initialization?), we simply propose that the synthesized constructors have associated implicit deduction guides the same as other constructors do.

<h2>Class Template Argument Deduction for alias templates</h2>
While Class Template Argument Deduction makes type inferencing easier when constructing classes,
it doesn't work for type aliases, penalizing the use of type aliases and creating unnecessary inconsistency. We propose allowing Class Template Argument Deduction for type aliases. The following example illustrates
how it makes <tt>pmr::vector</tt> as easy to deduce as <tt>vector</tt> (<tt>c</tt>:
<table border="1"><tr><th><tt>vector</tt></th><th><tt>pmr::vector</tt> (C++17)</th><th>pmr::vector (proposed)</th></tr>
<tr>
    <td>
<pre class="brush:cpp">vector v = {1, 2, 3};
vector v2(cont.begin(), cont.end());</pre>
    </td>
    <td><pre class="brush:cpp">pmr::vector&lt;int&gt; v({1, 2, 3}, mem_res);
pmr::vector&lt;decltype(cont)::value_type&gt; v2(cont.begin(), cont.end(), mem_res);</pre>
    </td>
<td><pre class="brush:cpp">pmr::vector v({1, 2, 3}, mem_res);
pmr::vector v2(cont.begin(), cont.end(), mem_res);</pre>
</td>
</tr></table>
In the spirit of alias templates being simply an alias for the type, we do not propose
allowing the programmer to write explicit deduction guides specifically for an alias
template.
	
<h2>Deducing from inherited constructors</h2>
In C++17, deduction guides (implicit and explicit) are not inherited when constructors are inherited.
	According to the C++ Core Guidelines <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-inheriting">C.52</a>, you should &ldquo;use inheriting constructors to import constructors into a derived class that does not need further explicit initialization&rdquo;. As the creator of such a thin wrapper has not asked in any way for the derived class to behave differently under construction, our experience is that users are
surprised that construction behavior changes:
<table border="1"><tr><td colspan="2">
<pre class="brush:cpp">template &lt;typename T&gt; struct CallObserver requires Invocable&lt;T&gt; { 
  CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {}
  virtual void observeCall() { t(); }
  T t;
};

template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { 
  using CallObserver&lt;T&gt;::CallObserver; 
  virtual void observeCall() override { cout &lt;&lt; "calling"; t();  }
};</pre>
</td></tr>
<tr><th>C++17</th> <th>Proposed</th></tr>
<tr><td>
	<pre class="brush:cpp">CallObserver b([]() { /* ... */ }); // OK
CallLogger&lt;/*????*/&gt; d([]() { /* ... */ });</pre>
</td>
<td><pre class="brush:cpp">CallObserver b([]() { /* ... */ }); // OK
Derived d([]() { /* ... */ }); // Now OK</pre>
    </td></tr></table>
Note that inheriting the constructors of a base class must include inheriting all the deduction guides, not just the implicit ones. As a number of standard library
writers use explicit guides to behave &ldquo;as-if&rdquo; their classes were defined as in the standard, such internal implementation details
details would become visible if only the internal guides were inherited.

<h2>Class Template Argument Deduction and partial template argument lists</h2>
    Partial template argument lists can be given in Function Template Argument Deduction
    but surprisingly fail in Class Template Argument Deduction, a restriction we propose removing.
    Not only is this more consistent, but it has powerful applications that resolve longstanding
    difficulties in C++, such as creating associative containers with lambda comparators, as the following 
    example shows.
    <table border="1"><tr><th>C++17</th><th>Proposed</th></tr>
<tr><td><pre class="brush:cpp">using namespace ba = boost::algorithm;

set&lt;string, ba::ilexicographic_compare&gt; case_insensitive_strings(ba::ilexicographic_compare);

// Lambda comparators are great for algorithms like sort
// Why can't we use them for associative containers?
set&lt;int, /* ???? */&gt; s([](int i, int j) { 
                          return std::popcount(i) &lt; std::popcount(j); 
                     }); 

// Or container adaptors?
priority_queue&lt;Task, vector&lt;Task&gt;, /* ???? */&gt; tasks([](Task a, Task b) {
                                                     return a.priority &lt; b.priority;
                                                   }); </pre>
    </td>
<td><pre class="brush:cpp">using namespace ba = boost::algorithm;

set&lt;string&gt; case_insensitive_strings(ba::ilexicographic_compare);

// Lambda comparators are great for algorithms like sort
// Now with associative containers, too!
set&lt;int&gt; s([](int i, int j) { 
              return std::popcount(i) &lt; std::popcount(j);
            }); 

// and container adaptors!
priority_queue&lt;Task&gt; tasks([](Task a, Task b) { 
                              return a.priority &lt; b.priority;
                         });</pre></td></tr></table>   

<h3>Technical considerations</h3>
    The above discussion naturally begs the question as to why partially-specialized template
    argument lists in Class Template Argument Discussion from the beginning. This feature
    was deferred in C++17 out of concern that it could result in breaking changes when partially-specialized
    template argument lists were combined with default arguments. Consider the expression
    <blockquote><pre class="brush:cpp">vector&lt;int&gt;(MyAlloc())</pre></blockquote>
As far back as C++98, this creates a <tt>vector&lt;int, allocator&lt;int&gt;&gt;</tt>,
    although it is unlikely to compile because <tt>MyAlloc</tt> almost certainly is not
    convertible to <tt>allocator&lt;int&gt;</tt>. By contrast, ordinary function template
    argument deduction would of course deduce <tt>vector&lt;int, MyAlloc&gt;</tt>.
    While this is exactly what we would want in this situation and is likely
    what we would have done if Class Template Argument Deduction was in C++ from the 
    beginning, we would now have to contend with it being a breaking change.
	<p>Fortunately, we can get the benefit of the usual Function Template Argument Deduction without breaking existing code by the following rule:
If a class has no explicit deduction guides, we propose that C++17 behavior applies where default template
        arguments override type inference. Which maintains the behavior of legacy C++ for classes that 
        were designed before Class Template Argument Deduction was introduced. If the class has explicit 
        guides, then do normal Function Template Argument Deduction. In particular, the above examples are handled correctly, and since any desired behavior can be specified, other examples can be handled as well.
</p>
<p>One other technical issue discussed during C++17 was around variadic templates. In particular, what should <tt>tuple&lt;int&gt;(1, 2.3)</tt> deduce?
Again, the C++17 behavior of <tt>tuple&lt;int&gt;</tt> is incorrect, as such templates have the wrong number of arguments. Fortunately, the normal
Function Template Argument Deduction behavior is a good choice here because it correctly
    deduces the same <tt>tuple&lt;int, double&gt;</tt> as <tt>make_tuple&lt;int&gt;(1, 2.3)</tt> 
    does, and as Nico Josuttis has observed, it would be bizarre if they deduced anything different.</p>

<h2>Wording</h2>
<script type="text/javascript">
	SyntaxHighlighter.defaults['gutter'] = false;
     SyntaxHighlighter.all()
</script>
	</body></html>